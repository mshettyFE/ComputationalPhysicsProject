import numpy as np
from StateVector import StateVector, StateVectorVar

# -------------------------------------------------------------------
# NOTE: Don't forget that density(\rho) is a function of Pressure(P) and Temperature(T)
# Therefore, you need to remember to take those derivatives!
# Remember: \rho_{half} = Utilities.equation_of_state(P_{half},T_{half}) = \mu (P_{k+1}-P_{k})/(T_{k+1}-T_{k})
# -------------------------------------------------------------------

# NOTE: dm = m_{k+1}-m_{k}. Assume this is a constant (ie. shells sizes are the same throughout)

# NOTE: This file houses the sub-matrix generator for the Jacobian, and the Jacobian calculator
# There are 16 functions, with each one dedicated to a particular sub block

# -------------------------------------------------------------------
# NOTE: We expect all submatrix calculations to have the same signature:
# state_vector_matrix: a 4xk dimensional array containing the values of the state array. Emitted from StateVector.emit_state_matrix
# interpolated_values: a 5x(k-1) dimensional array containing the interpolated values of the state vector (plus density)
#   Generated by StateVector.interpolate_all()

# Output: We expect the output of each function to be a nxn matrix
# where n = (k-1), where k is the number of shells
# Stitching everything together should give a 4(k-1) square matrix
# To take into account the boundary conditions, we use stitch_vector on the state vector
# -------------------------------------------------------------------



# -------------------------------------------------------------------
# NOTE: For now, just use random matrices so that I can work on the rest  of the pipeline (Can't invert 0 matrix!)
# -------------------------------------------------------------------

# Difference equation for radius
# (r_{k+1}-r_{k})/(dm)- 1/(4*pi*r^{2}_{half}* \rho_{half})

# Radius
def Jac_block_00(state_vector_matrix, dm, constants):
    mu = constants["mu"]
    output_dim = state_vector_matrix.shape[1]-1
    output = np.zeros((output_dim, output_dim))
    for shell in range(0,state_vector_matrix.shape[0]-1): # Run through all of the shells
        dp = (state_vector_matrix[StateVectorVar.PRESSURE.value,shell+1]-state_vector_matrix[StateVectorVar.PRESSURE.value,shell])
        dT = (state_vector_matrix[StateVectorVar.TEMP.value,shell+1]-state_vector_matrix[StateVectorVar.TEMP.value,shell])
        density = mu*dp/dT
        summed_rad = state_vector_matrix[StateVectorVar.RADIUS.value,shell+1]+state_vector_matrix[StateVectorVar.RADIUS.value,shell]
        alpha = -1/dm+(2*mu/np.pi)*density/np.power(summed_rad,3)
        beta = 1/dm+(2*mu/np.pi)*density/np.power(summed_rad, 3)
        if (shell == 0):
            output[0,0] = beta
        else:
            output[shell, shell] = beta
            output[shell, shell-1] = alpha
    return output

# Pressure
def Jac_block_01(state_vector_matrix, dm, constants):
    mu = constants["mu"]
    output_dim = state_vector_matrix.shape[1]-1
    output = np.zeros((output_dim, output_dim))
    for shell in range(0,state_vector_matrix.shape[0]-1): # Run through all of the shells
        dT = (state_vector_matrix[StateVectorVar.TEMP.value,shell+1]-state_vector_matrix[StateVectorVar.TEMP.value,shell])
        summed_rad = state_vector_matrix[StateVectorVar.RADIUS.value,shell+1]+state_vector_matrix[StateVectorVar.RADIUS.value,shell]
        alpha = (mu/np.pi)/np.power(dT,1)/np.power(summed_rad,2)
        beta = alpha
        if (shell == 0):
            output[0,0] = beta
        else:
            output[shell, shell] = beta
            output[shell, shell-1] = alpha
    return output

# Temperature
def Jac_block_02(state_vector_matrix, dm, constants):
    output = np.random.rand(state_vector_matrix.shape[1]-1,state_vector_matrix.shape[1]-1)
    return output

# Luminosity
def Jac_block_03(state_vector_matrix, dm, constants):
    output = np.random.rand(state_vector_matrix.shape[1]-1,state_vector_matrix.shape[1]-1)
    return output

# Difference equation for Pressure
# (P_{k+1}-P_{k})/(dm) +  (dm/2)/(4*pi*r^{4}_{half})

# Radius
def Jac_block_10(state_vector_matrix, dm, constants):
    output = np.random.rand(state_vector_matrix.shape[1]-1,state_vector_matrix.shape[1]-1)
    return output

# Pressure
def Jac_block_11(state_vector_matrix, dm, constants):
    output = np.random.rand(state_vector_matrix.shape[1]-1,state_vector_matrix.shape[1]-1)
    return output

# Temperature
def Jac_block_12(state_vector_matrix, dm, constants):
    output = np.random.rand(state_vector_matrix.shape[1]-1,state_vector_matrix.shape[1]-1)
    return output

# Luminosity
def Jac_block_13(state_vector_matrix, dm, constants):
    output = np.random.rand(state_vector_matrix.shape[1]-1,state_vector_matrix.shape[1]-1)
    return output

# Difference equation for Temperature
# (T_{k+1}-T_{k})/(dm)+ \kappa_0 \rho_{half}* L_{half}/r^{4}_{half}/T^{6.5}_{half}

# Radius
def Jac_block_20(state_vector_matrix, dm, constants):
    output = np.random.rand(state_vector_matrix.shape[1]-1,state_vector_matrix.shape[1]-1)
    return output

# Pressure
def Jac_block_21(state_vector_matrix, dm, constants):
    output = np.random.rand(state_vector_matrix.shape[1]-1,state_vector_matrix.shape[1]-1)
    return output

# Temperature
def Jac_block_22(state_vector_matrix, dm, constants):
    output = np.random.rand(state_vector_matrix.shape[1]-1,state_vector_matrix.shape[1]-1)
    return output

# Luminosity
def Jac_block_23(state_vector_matrix, dm, constants):
    output = np.random.rand(state_vector_matrix.shape[1]-1,state_vector_matrix.shape[1]-1)
    return output

# Difference equation for luminosity
# (L_{k+1}-L_{k})/(dm)- \epsilon_0 \rho_{half}*T_{half}^{4}=g

# Radius
def Jac_block_30(state_vector_matrix, dm, constants):
    output = np.random.rand(state_vector_matrix.shape[1]-1,state_vector_matrix.shape[1]-1)
    return output

# Pressure
def Jac_block_31(state_vector_matrix, dm, constants):
    output = np.random.rand(state_vector_matrix.shape[1]-1,state_vector_matrix.shape[1]-1)
    return output

# Temperature
def Jac_block_32(state_vector_matrix, dm, constants):
    output = np.random.rand(state_vector_matrix.shape[1]-1,state_vector_matrix.shape[1]-1)
    return output

# Luminosity
def Jac_block_33(state_vector_matrix, dm, constants):
    output = np.random.rand(state_vector_matrix.shape[1]-1,state_vector_matrix.shape[1]-1)
    return output

def gen_Jacobian(state_vector: StateVector, constants):
    """
        Outputs the Jacobian of the residual function needed for Newton-Raphson
        Input:
            state_vector: Instance of StateVector
        Output:
            nxn Jacobian matrix, where n = 4*(k-1), where k is the number of shells
            Need to use Utilities.stich_vector to make this Jacobian useful in NR method
    """
    interpolated_values = state_vector.interpolate_all(constants)
    dm = 1/state_vector.n_shells
    state_vector_matrix = state_vector.emit_state_matrix()

    J00 = Jac_block_00(state_vector_matrix, dm, constants)
    J01 = Jac_block_01(state_vector_matrix, dm, constants)
    J02 = Jac_block_02(state_vector_matrix, dm, constants)
    J03 = Jac_block_03(state_vector_matrix, dm, constants)
    J0 = np.concatenate([J00, J01, J02, J03], axis=1)

    J10 = Jac_block_10(state_vector_matrix, dm, constants)
    J11 = Jac_block_11(state_vector_matrix, dm, constants)
    J12 = Jac_block_12(state_vector_matrix, dm, constants)
    J13 = Jac_block_13(state_vector_matrix, dm, constants)
    J1 = np.concatenate([J10, J11, J12, J13], axis=1)

    J20 = Jac_block_20(state_vector_matrix, dm, constants)
    J21 = Jac_block_21(state_vector_matrix, dm, constants)
    J22 = Jac_block_22(state_vector_matrix, dm, constants)
    J23 = Jac_block_23(state_vector_matrix, dm, constants)
    J2 = np.concatenate([J20, J21, J22, J23], axis=1)

    J30 = Jac_block_30(state_vector_matrix, dm, constants)
    J31 = Jac_block_31(state_vector_matrix, dm, constants)
    J32 = Jac_block_32(state_vector_matrix, dm, constants)
    J33 = Jac_block_33(state_vector_matrix, dm, constants)
    J3 = np.concatenate([J30, J31, J32, J33], axis=1)
    
    out = np.concatenate([J0,J1,J2,J3], axis=0)
    return out


if __name__=="__main__":
    pass