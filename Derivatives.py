import numpy as np
from StateVector import StateVector, StateVectorVar, InterpolationIndex
import Utilities

# -------------------------------------------------------------------
# NOTE: Don't forget that density(\rho) is a function of Pressure(P) and Temperature(T)
# Therefore, you need to remember to take those derivatives!
# Remember: \rho_{half} = Utilities.equation_of_state(P_{half},T_{half}) = \mu (P_{k+1}-P_{k})/(T_{k+1}-T_{k})
# -------------------------------------------------------------------

# NOTE: dm = m_{k+1}-m_{k}. Assume this is a constant (ie. shells sizes are the same throughout)

# NOTE: This file houses the sub-matrix generator for the Jacobian, and the Jacobian calculator
# There are 16 functions, with each one dedicated to a particular sub block

# -------------------------------------------------------------------
# NOTE: We expect all submatrix calculations to have the same signature:
# state_vector_matrix_interp: a 4x(k-1) dimensional array containing the values of the state array.
# state_vector_matrix_diff: a 4x(k-1) dimensional array containing the difference between adjacent elements
#   Generated by StateVector.dif_vars()

# Output: We expect the output of each function to be a nxn matrix
# where n = (k-1), where k is the number of shells
# Stitching everything together should give a 4(k-1) square matrix
# To take into account the boundary conditions, we use stitch_vector on the state vector
# -------------------------------------------------------------------


# Difference equation for radius
# (r_{k+1}-r_{k})/(dm)- 1/(4*pi*r^{2}_{half}* \rho_{half})

# Radius
def Jac_block_rr(state_vector_matrix_interp, dm, constants, verbose=False):
    output_dim = state_vector_matrix_interp.shape[1]
    output = np.zeros((output_dim, output_dim))
    density = state_vector_matrix_interp[InterpolationIndex.DENSITY.value]
    all_rad = state_vector_matrix_interp[InterpolationIndex.RADIUS.value]

    alpha = -1/dm+(1/(4*np.pi))/density/np.power(all_rad, 3) # r_k
    beta = 1/dm+(2/np.pi)/density/np.power(all_rad,3) # r_{k+1}
    for shell in range(0,output_dim): # Run through all of the shells
        if (shell == 0): # r_0 doesn't change, so only include \delta r_{1} term
            output[0,0] = beta[0]
        else:
            output[shell, shell] = beta[shell]
            output[shell, shell-1] = alpha[shell]
    if(verbose):
        print("00_min",output.min())
        print("00_max",output.max())
    return output

# Pressure
def Jac_block_rp(state_vector_matrix_interp, dm, constants, verbose=False):
    output_dim = state_vector_matrix_interp.shape[1]
    output = np.zeros((output_dim, output_dim))
    density = state_vector_matrix_interp[InterpolationIndex.DENSITY.value]
    all_rad = state_vector_matrix_interp[InterpolationIndex.RADIUS.value]

    alpha = -1/(4*np.pi)/np.power(all_rad,2)/np.power(density,2)
    beta = -alpha # P_k+1
    for shell in range(0,output_dim): # Run through all of the shells
        if (shell == output_dim-1): # P_k-1 doesn't change, so only include \delta p_{k-2} term
            output[output_dim-1,output_dim-1] = alpha[output_dim-1]
        else:
            output[shell, shell] = alpha[shell]
            output[shell, shell+1] = beta[shell]
    if(verbose):
        print("01_min",output.min())
        print("01_max",output.max())
    return output

# Temperature
def Jac_block_rt(state_vector_matrix_interp, dm, constants, verbose=False):
    output_dim = state_vector_matrix_interp.shape[1]
    output = np.zeros((output_dim, output_dim))

    density = state_vector_matrix_interp[InterpolationIndex.DENSITY.value]
    all_rad = state_vector_matrix_interp[InterpolationIndex.RADIUS.value]
    all_t = state_vector_matrix_interp[InterpolationIndex.TEMP.value]

    alpha = -1/(4*np.pi)/np.power(all_rad,2)/np.power(density,2)/all_t
    beta = -alpha # T_k+1

    for shell in range(0,output_dim): # Run through all of the shells
        if (shell == output_dim-1): # T_k-1 doesn't change, so only include \delta T_{k-2} term
            output[output_dim-1,output_dim-1] = alpha[output_dim-1]
        else:
            output[shell, shell] = alpha[shell]
            output[shell, shell+1] = beta[shell]
    if(verbose):
        print("02_min",output.min())
        print("02_max",output.max())
    return output
# Luminosity
def Jac_block_rl(state_vector_matrix_interp, dm, constants, verbose=False):
    output = np.zeros((state_vector_matrix_interp.shape[1],state_vector_matrix_interp.shape[1]))
    if(verbose):
        print("03_min",output.min())
        print("03_max",output.max())
    return output

# Difference equation for Pressure
# (P_{k+1}-P_{k})/(dm) +  (dm/2)/(4*pi*r^{4}_{half})

# Radius
def Jac_block_pr(state_vector_matrix_interp, dm, constants, verbose=False):
    output_dim = state_vector_matrix_interp.shape[1]
    output = np.zeros((output_dim,output_dim))
    interp_rad = state_vector_matrix_interp[InterpolationIndex.RADIUS.value]
    val = (-1/(4*np.pi)) *dm /np.power(interp_rad,5)

    for shell in range(0,output_dim): # Run through all of the shells
        if (shell == 0): # r_0 doesn't change, so only include \delta r_{1} term
            output[0,0] = val[0]
        else:
            output[shell, shell] = val[shell]
            output[shell, shell-1] = val[shell]
    if(verbose):
        print("10_min",output.min())
        print("10_max",output.max())
    return output

# Pressure
def Jac_block_pp(state_vector_matrix_interp, dm, constants, verbose=False):
    output_dim = state_vector_matrix_interp.shape[1]
    output = np.zeros((output_dim,output_dim))
    alpha = -np.ones(output_dim)/dm
    beta = -alpha
    for shell in range(0,output_dim): # Run through all of the shells
        if (shell == output_dim-1): # P_k-1 doesn't change, so only include \delta p_{k-2} term
            output[output_dim-1,output_dim-1] = alpha[output_dim-1]
        else:
            output[shell, shell] = alpha[shell]
            output[shell, shell+1] = beta[shell]
    if(verbose):
        print("11_min",output.min())
        print("11_max",output.max())
    return output

# Temperature
def Jac_block_pt(state_vector_matrix_interp, dm, constants, verbose=False):
    output_dim = state_vector_matrix_interp.shape[1]
    output = np.zeros((output_dim,output_dim))
    if(verbose):
        print("12_min",output.min())
        print("12_max",output.max())
    return output

# Luminosity
def Jac_block_pl(state_vector_matrix_interp, dm, constants, verbose=False):
    output_dim = state_vector_matrix_interp.shape[1]
    output = np.zeros((output_dim,output_dim))
    if(verbose):
        print("13_min",output.min())
        print("13_max",output.max())
    return output

# Difference equation for Temperature
# (T_{k+1}-T_{k})/(dm)+ \kappa_0 \rho_{half}* L_{half}/r^{4}_{half}/T^{6.5}_{half}

# Radius
def Jac_block_tr(state_vector_matrix_interp, dm, constants, verbose=False):
    output_dim = state_vector_matrix_interp.shape[1]
    summed_r = state_vector_matrix_interp[InterpolationIndex.RADIUS.value]
    summed_l = state_vector_matrix_interp[InterpolationIndex.LUMINOSITY.value]
    summed_t = state_vector_matrix_interp[InterpolationIndex.TEMP.value]
    density = state_vector_matrix_interp[InterpolationIndex.DENSITY.value]
    val = -2*constants["k0_prime"]*density*summed_l/np.power(summed_r,5)/np.power(summed_t,6.5)
    output = np.zeros((output_dim,output_dim))
    for shell in range(0,output_dim): # Run through all of the shells
        if (shell == 0): # r_0 doesn't change, so only include \delta r_{1} term
            output[0,0] = val[0]
        else:
            output[shell, shell] = val[shell]
            output[shell, shell-1] = val[shell]
    if(verbose):
        print("20_min",output.min())
        print("20_max",output.max())
    return output

# Pressure
def Jac_block_tp(state_vector_matrix_interp, dm, constants, verbose=False):
    output_dim = state_vector_matrix_interp.shape[1]
    summed_r = state_vector_matrix_interp[InterpolationIndex.RADIUS.value]
    summed_t = state_vector_matrix_interp[InterpolationIndex.TEMP.value]
    summed_p = state_vector_matrix_interp[InterpolationIndex.PRESSURE.value]
    summed_l = state_vector_matrix_interp[InterpolationIndex.LUMINOSITY.value]
    drho_dp = Utilities.equation_of_state_dp(summed_p,summed_t, constants)
    output = np.zeros((output_dim,output_dim))
    alpha = constants["k0_prime"]*drho_dp*summed_l/np.power(summed_r,4)/np.power(summed_t,6.5)
    beta = -alpha
    for shell in range(0,output_dim): # Run through all of the shells
        if (shell == output_dim-1): # P_k-1 doesn't change, so only include \delta p_{k-2} term
            output[output_dim-1,output_dim-1] = alpha[output_dim-1]
        else:
            output[shell, shell] = alpha[shell]
            output[shell, shell+1] = beta[shell]
    if(verbose):
        print("21_min",output.min())
        print("21_max",output.max())
    return output

# Temperature
def Jac_block_tt(state_vector_matrix_interp, dm, constants, verbose=False):
    output_dim = state_vector_matrix_interp.shape[1]
    summed_r = state_vector_matrix_interp[InterpolationIndex.RADIUS.value]
    summed_l = state_vector_matrix_interp[InterpolationIndex.LUMINOSITY.value]
    summed_t = state_vector_matrix_interp[InterpolationIndex.TEMP.value]
    summed_p = state_vector_matrix_interp[InterpolationIndex.PRESSURE.value]
    density = state_vector_matrix_interp[InterpolationIndex.DENSITY.value]
    output = np.zeros((output_dim,output_dim))
    drho_dt = Utilities.equation_of_state_dt(summed_p,summed_t,constants)

    part_one = -np.ones(output_dim)/dm
    prefactor = constants["k0_prime"]*summed_l/np.power(summed_r,4)
    prod_one = drho_dt/np.power(summed_t,6.5)
    prod_two = density*-6.5*0.5/np.power(summed_t,7.5)
    alpha = part_one+prefactor*(prod_one+prod_two)
    beta = -part_one+prefactor*(-prod_one+prod_two)
    for shell in range(0,output_dim): # Run through all of the shells
        if (shell == output_dim-1): # t_k-1 doesn't change, so only include \delta t_{k-2} term
            output[output_dim-1,output_dim-1] = alpha[output_dim-1]
        else:
            output[shell, shell] = alpha[shell]
            output[shell, shell+1] = beta[shell]
    if(verbose):
        print("22_min",output.min())
        print("22_max",output.max())
    return output

# Luminosity
def Jac_block_tl(state_vector_matrix_interp, dm, constants, verbose=False):
    summed_r = state_vector_matrix_interp[InterpolationIndex.RADIUS.value]
    summed_t = state_vector_matrix_interp[InterpolationIndex.TEMP.value]
    density = state_vector_matrix_interp[InterpolationIndex.DENSITY.value]
    output_dim = state_vector_matrix_interp.shape[1]
    output = np.zeros((output_dim,output_dim))

    val = 0.5*constants["k0_prime"]*density/np.power(summed_r,4)/np.power(summed_t,6.5)

    for shell in range(0,output_dim): # Run through all of the shells
        if (shell == 0): # L_0 doesn't change, so only include \delta L_{1} term
            output[0,0] = val[0]
        else:
            output[shell, shell] = val[shell]
            output[shell, shell-1] = val[shell]
    if(verbose):
        print("23_min",output.min())
        print("23_max",output.max())
    return output

# Difference equation for luminosity
# (L_{k+1}-L_{k})/(dm)- \epsilon_0 \rho_{half}*T_{half}^{4}=g

# Radius
def Jac_block_lr(state_vector_matrix_interp, dm, constants, verbose=False):
    output_dim = state_vector_matrix_interp.shape[1]
    output = np.zeros((output_dim,output_dim))
    if(verbose):
        print("30_min",output.min())
        print("30_max",output.max())
    return output

# Pressure
def Jac_block_lp(state_vector_matrix_interp, dm, constants, verbose=False):
    output_dim = state_vector_matrix_interp.shape[1]
    output = np.zeros((output_dim,output_dim))
    summed_t = state_vector_matrix_interp[InterpolationIndex.TEMP.value]
    summed_p = state_vector_matrix_interp[InterpolationIndex.TEMP.value]
    drho_dp = Utilities.equation_of_state_dp(summed_p, summed_t, constants)

    alpha = -constants["E0_prime"]*drho_dp*np.power(summed_t,4)
    beta = -alpha

    for shell in range(0,output_dim): # Run through all of the shells
        if (shell == output_dim-1): # P_k-1 doesn't change, so only include \delta p_{k-2} term
            output[output_dim-1,output_dim-1] = alpha[output_dim-1]
        else:
            output[shell, shell] = alpha[shell]
            output[shell, shell+1] = beta[shell]
    if(verbose):
        print("31_min",output.min())
        print("31_max",output.max())
    return output

# Temperature
def Jac_block_lt(state_vector_matrix_interp, dm, constants, verbose=False):
    output_dim = state_vector_matrix_interp.shape[1]
    output = np.zeros((output_dim,output_dim))
    summed_t = state_vector_matrix_interp[InterpolationIndex.TEMP.value]
    summed_p = state_vector_matrix_interp[InterpolationIndex.PRESSURE.value]
    density = state_vector_matrix_interp[InterpolationIndex.DENSITY.value]
    drho_dt = Utilities.equation_of_state_dt(summed_p, summed_t, constants)

    part_one = constants["E0_prime"]*drho_dt*np.power(summed_t,4)
    part_two = constants["E0_prime"]*density*4*0.5*np.power(summed_t,3)
    alpha = (part_one+part_two)
    beta = (-part_one+part_two)

    for shell in range(0,output_dim): # Run through all of the shells
        if (shell == output_dim-1): # t_k-1 doesn't change, so only include \delta t_{k-2} term
            output[output_dim-1,output_dim-1] = alpha[output_dim-1]
        else:
            output[shell, shell] = alpha[shell]
            output[shell, shell+1] = beta[shell]
    if(verbose):
        print("32_min",output.min())
        print("32_max",output.max())
    return output

# Luminosity
def Jac_block_ll(state_vector_matrix_interp, dm, constants, verbose=False):
    output_dim = state_vector_matrix_interp.shape[1]
    output = np.zeros((output_dim,output_dim))
    alpha = -np.ones(output_dim)/dm
    beta = -alpha
    for shell in range(0,output_dim): # Run through all of the shells
        if (shell == 0): # L_k-1 doesn't change, so only include \delta L_{k-2} term
            output[0,0] = beta[0]
        else:
            output[shell, shell] = beta[shell]
            output[shell, -shell] = alpha[shell]
    if(verbose):
        print("33_min",output.min())
        print("33_max",output.max())
    return output

def gen_Jacobian(state_vector: StateVector, constants, verbose=False):
    """
        Outputs the Jacobian of the residual function needed for Newton-Raphson
        Input:
            state_vector: Instance of StateVector
        Output:
            nxn Jacobian matrix, where n = 4*(k-1), where k is the number of shells
            Need to use Utilities.stich_vector to make this Jacobian useful in NR method
    """
    interp_vals = state_vector.interpolate_all(constants)
    dm = 1/state_vector.n_shells
    block_size =(state_vector.n_shells-1) 
    out_dim = 4*block_size
    output = np.zeros((out_dim, out_dim))

    J00 = Jac_block_rr(interp_vals, dm, constants,verbose)
    J01 = Jac_block_rp(interp_vals, dm, constants,verbose)
    J02 = Jac_block_rt(interp_vals, dm, constants,verbose)
    J03 = Jac_block_rl(interp_vals, dm, constants,verbose)

    J10 = Jac_block_pr(interp_vals, dm, constants,verbose)
    J11 = Jac_block_pp(interp_vals, dm, constants,verbose)
    J12 = Jac_block_pt(interp_vals, dm, constants,verbose)
    J13 = Jac_block_pl(interp_vals, dm, constants,verbose)

    J20 = Jac_block_tr(interp_vals, dm, constants,verbose)
    J21 = Jac_block_tp(interp_vals, dm, constants,verbose)
    J22 = Jac_block_tt(interp_vals, dm, constants,verbose)
    J23 = Jac_block_tl(interp_vals, dm, constants,verbose)

    J30 = Jac_block_lr(interp_vals, dm, constants,verbose)
    J31 = Jac_block_lp(interp_vals, dm, constants,verbose)
    J32 = Jac_block_lt(interp_vals, dm, constants,verbose)
    J33 = Jac_block_ll(interp_vals, dm, constants,verbose)
    
    output[0:block_size,0:block_size] = J00
    output[0:block_size, block_size:2*block_size] = J01
    output[0:block_size, 2*block_size:3*block_size] = J02
    output[0:block_size, 3*block_size:4*block_size] = J03
    output[block_size:2*block_size,0:block_size] = J10
    output[block_size:2*block_size, block_size:2*block_size] = J11
    output[block_size:2*block_size, 2*block_size:3*block_size] = J12
    output[block_size:2*block_size, 3*block_size:4*block_size] = J13
    output[2*block_size:3*block_size,0:block_size] = J20
    output[2*block_size:3*block_size, block_size:2*block_size] = J21
    output[2*block_size:3*block_size, 2*block_size:3*block_size] = J22
    output[2*block_size:3*block_size, 3*block_size:4*block_size] = J23
    output[3*block_size:4*block_size,0:block_size] = J30
    output[3*block_size:4*block_size, block_size:2*block_size] = J31
    output[3*block_size:4*block_size, 2*block_size:3*block_size] = J32
    output[3*block_size:4*block_size, 3*block_size:4*block_size] = J33
    if(verbose):
        print("J_min",output.min())
        print("J_max",output.max())
    return output


if __name__=="__main__":
    pass