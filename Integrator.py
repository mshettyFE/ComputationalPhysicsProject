import numpy as np
import scipy as sp;
from Utilities import *
import copy

def derivative_calc(current, extra_const_params):
    """
        Differential equation for pressure
        current: 1x6 numpy array containing the current values for each variable. See Utilities for indices  of current vector
        extra_const_parameters: dictionary generated by Utilities.gen_extra_parameters. Not used in all dif. eqs
        Output: 1x6 numpy array stating change in each variable. Density is not updated
    """
    delta = np.zeros(current.shape)
    dr = (1/(4*np.pi))*(1/(np.power(current[RADIUS_UNIT_INDEX],2)*current[DENSITY_UNIT_INDEX]))
    delta[RADIUS_UNIT_INDEX] = dr

    dP = (-1/(4*np.pi))* (current[MASS_UNIT_INDEX])* np.power(current[RADIUS_UNIT_INDEX], -4)
    delta[PRESSURE_UNIT_INDEX] = dP

    dL = extra_const_params["E_prime"]* current[DENSITY_UNIT_INDEX]*np.power(current[TEMP_UNIT_INDEX],4)
    delta[LUMINOSITY_UNIT_INDEX] = dL

    # assume that kappa_prime is in args
    cur_t = current[TEMP_UNIT_INDEX]
    multiplied_vars = cur_t* current[RADIUS_UNIT_INDEX]
    var = np.power(multiplied_vars, -4)
    tp = np.power(cur_t,-2.5) #!!!                   OVERFLOW/NaN being encountered               !!!
    dT = - extra_const_params["kappa_prime"]* current[DENSITY_UNIT_INDEX] * current[LUMINOSITY_UNIT_INDEX] * var * tp 
    delta[TEMP_UNIT_INDEX] = dT
    delta[MASS_UNIT_INDEX] = 1
    delta[DENSITY_UNIT_INDEX] = 0
    return delta


def RK4(f, current, step_size, extra_const_params):
    """
    Straightforward implementation of RK4 algorithm
    Inputs:
        f: derivative of dependent variable. Takes form f(current, extra_const_params),
            * current encodes the current state of the system as a 6x1 np array
            * constant_dict is a Python dictionary which holds any constants needed amongst all the diff eqs
            f should output a numpy array with size of current (6x1)
        current: numpy array which holds the current state of the system
            0th term is independent variable, and the rest are the dependent ones
        step_size: how big of a step in x do you want
    Output:
        1x6 numpy array containing Derivatives of all variables of current. Independent variable (mass) is just step size. Density is calculated outside of RK4
    """
    assert(step_size >0)
    step_size = np.float64(step_size)
    half_step_size = step_size/2
    
    #k1-k4 are reference points for RK integration.
    k1 = f(current,extra_const_params)
    new_input = current + half_step_size*k1 

    k2 = f(new_input,extra_const_params)
    
    new_input =current + half_step_size*k2 
    k3 = f(new_input,extra_const_params)

    new_input = current+step_size*k3
    
    k4 = f(new_input,extra_const_params)
    update = (step_size/6) * (k1+2*k2+2*k3+k4)

    # Return change in variables
    return update

if __name__ == "__main__":
    pass


#Iterates state of system thru RK4, creating an array of the key variables at each mass step.
def ODESolver(initial_conditions, num_steps, extra_const_parameters, verbose=False):
    """
        Inputs:
            initial_conditions (1x6 np array): The initial conditions of the system
            num_steps (np.float64): The number of steps to take between 0 and 1
        Outputs:
            state_matrix ( (num_stepsx6) np array):
                The state of the system at each mass step in time. Needed for plotting reasons
                The final state is given by state_matrix[:,-1]
    """
    step_size = 1/num_steps
    cur_state = initial_conditions
    output = [initial_conditions]
    for i in range(1, num_steps):
        delta  = RK4(derivative_calc, cur_state, step_size, extra_const_parameters)
        if(verbose):
            print(i, cur_state, delta)
        # Check if numerical instability happened. If so, terminate early
        if(np.any(np.isnan(delta))):
            break
        cur_state = cur_state +delta
        # Update density since it doesn't have it's own differential equation
        cur_state[DENSITY_UNIT_INDEX] = equation_of_state(cur_state[PRESSURE_UNIT_INDEX], cur_state[TEMP_UNIT_INDEX], extra_const_parameters)
        # Copy used here to prevent all data being the same
        output.append( copy.deepcopy(cur_state) )
    # Generate the output mesh
    o = np.vstack(output)
    return o

if __name__ == "__main__":
    pass
